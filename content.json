{"meta":{"title":"iamasd","subtitle":"Exploration never stops","description":"Exploration never stops","author":"iamasd","url":"http://www.iamasd.cn","root":"/"},"pages":[{"title":"","date":"2019-12-06T03:14:33.246Z","updated":"2019-12-06T03:14:33.240Z","comments":false,"path":"categories/index.html","permalink":"http://www.iamasd.cn/categories/index.html","excerpt":"","text":""},{"title":"友情鏈接","date":"2018-06-07T14:17:49.000Z","updated":"2019-12-06T05:16:00.958Z","comments":true,"path":"link/index.html","permalink":"http://www.iamasd.cn/link/index.html","excerpt":"","text":""},{"title":"分類","date":"2018-01-04T16:00:00.000Z","updated":"2019-12-06T05:14:23.297Z","comments":true,"path":"tags/index.html","permalink":"http://www.iamasd.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"深入理解JVM-----(二)","slug":"jvm2","date":"2019-12-10T11:05:15.000Z","updated":"2019-12-10T11:53:29.151Z","comments":true,"path":"2019/12/10/jvm2/","link":"","permalink":"http://www.iamasd.cn/2019/12/10/jvm2/","excerpt":"","text":"深入理解JVM之对象1.对象是怎么来的？1.1 对象的创建 对象创建的流程 虚拟机遇到一条new指令是，首先会检查这个对应的类能否在常量池中定义到一个类的符号引用 判断这个类是否已被加载，解析以及初始化 问这个新对象在Java队中分配内存空间——2种方法 指针碰撞 空闲列表 将分配的内存空间初始化为零值 设置对象头数据 GC分代年龄 对象的哈希码hashCode 元数据信息 执行对象方法 1.2 对象结构 对象头用于存储对象的元数据信息： Mark Word 部分数据的长度为32bit或64bit，存储对象自身运行时的数据—哈希值等。Mark Word一般被设计为非固定的数据结构，以便于存储更多的数据信息和复用自己的存储空间 类型指针：指向它的类元数据的指针，用于判断对象属于那个类的实例。 示例数据存储的时真正有效的数据。 对其填充部分只起到占位符的作用。 2.如何访问对象？2.1 对象的访问 在堆上创建一个对象实例之后，就要通过虚拟机栈中的reference类型数据来操作堆上的对象。 使用句柄访问 直接指针访问（HotSpot虚拟机） 2.2 对比 垃圾回收对比：1中，当垃圾回收移动对象时，reference中存储的地址时稳定的地址，不需要修改，仅需要修改对象句柄的地址；2中，垃圾回收的时候只需要修改reference中存储的地址。 访问效率分析，2&gt;1,因为2只进行了一次指针定位，节省了时间的开销 3.注解 指针碰撞 分配内存空间包括开辟一块内存和移动指针两个步骤 通俗来讲，在一块内存区域中，存在一个指针，当一个对象创建需要内存空间的时候，指针就向未使用的内存移动相应要创建内存大小的位置。它就像一块围墙，将使用与未使用的内存空间隔离。 非原子步骤可能会出项并发问题，Java虚拟机采用CAS(乐观锁)配上失败重试的方式来保证更新的操作原子性 空闲列表 分配内存空间包括开辟一块内存，和修改空闲列表两个步骤。 分配表相当于一个宿管阿姨的登记表，你要住宿，那就给你登记，分配住房。 非原子步骤可能会出项并发问题，Java虚拟机采用CAS(乐观锁)配上失败重试的方式来保证更新的操作原子性","categories":[{"name":"jvm","slug":"jvm","permalink":"http://www.iamasd.cn/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://www.iamasd.cn/tags/jvm/"}]},{"title":"Spring基础组件-----@Configuration","slug":"Configuration","date":"2019-12-09T01:05:15.000Z","updated":"2019-12-09T02:49:52.000Z","comments":true,"path":"2019/12/09/Configuration/","link":"","permalink":"http://www.iamasd.cn/2019/12/09/Configuration/","excerpt":"","text":"Spring基础组件—-@Configuration引言 本篇博文，本着简易使用以及简易理解的目的，不针对源码进行分析。如果有不正确的地方，还麻烦各位多多指正以下。Bean的注册有6种方式，本文只讨论2种 1.Bean1.1 Spring XML 创建Bean 在原始的操作中，我们会使用Spring XML的方式来配置。这样的使用，会使得在之后注册大量的bean，导致XML配置文件膨胀，不利于对象的操作。 这里先创建一个Person类： 1/**2 * @Author: iamasd3 * @Description:4 * @Date: Created in 18:112019/12/65 */6public class Person &#123;78 private String name;910 private Integer age;1112 public Person(String name, Integer age) &#123;13 this.name = name;14 this.age = age;15 &#125;1617 public String getName() &#123;18 return name;19 &#125;2021 public void setName(String name) &#123;22 this.name = name;23 &#125;2425 public Integer getAge() &#123;26 return age;27 &#125;2829 public void setAge(Integer age) &#123;30 this.age = age;31 &#125;3233 @Override34 public String toString() &#123;35 return \"Person&#123;\" +36 \"name='\" + name + '\\'' +37 \", age=\" + age +38 '&#125;';39 &#125;40&#125; 接下来是XML文件的配置： 1&lt;bean id=\"person\" class=\"cn.sq.demo1.Person\"&gt;2 &lt;constructor-arg index=\"0\" value=\"iamasd\"/&gt;3 &lt;constructor-arg index=\"1\" value=\"18\"/&gt;4&lt;/bean&gt; 这样的是通过有参构造器，在向IOC容器注册Bean的时候，通过构造器对其属性值进行赋值操作。或者我们可以不通过对象的构造器，将Person中的构造器注释，直接在XML的文件中通过Bean标签中的property标签，对对象内的属性赋值。 1&lt;bean id=\"person\" class=\"cn.sq.demo1.Person\"&gt;2 &lt;property name=\"name\" value=\"iamasd\"/&gt;3 &lt;property name=\"age\" value=\"18\"/&gt;4&lt;/bean&gt; 写一个测试用例 1/**2 * @Author: iamasd3 * @Description:4 * @Date: Created in 18:512019/12/65 */67public class TestDemo1 &#123;8910 @Test11 public void run1()&#123;12 //AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig.class);13 ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:application.xml\");14 Person person = (Person)context.getBean(\"person\");15 System.out.println(person);16 &#125;17&#125;1819结果：Person&#123;name='iamasd', age=18&#125;202122以上便是最基础的XML配置，使对象注入到IOC容器中。但是，随着要注册的对象增多，会导致XML文件的臃肿，不推荐使用。 1.2 @Configuration+@Bean 除了第一个方法，我们还可以通过@Configuration这个注解，来表明这是一个配置类， 这个类可以使用Spring IoC容器作为bean定义的来源。 @Bean 注解在该类的方法上，AnnotationConfigApplicationContext将配置类中标注了 @Bean的方法的返回值识别为Spring Bean，并注册到容器中，归入IoC容器管理。其定义意义上上等同于Spring XML文件中的标签。 以下是一个简单的实例： 1/**2 * @Author: iamasd3 * @Description:4 * @Date: Created in 18:222019/12/65 */6@Configuration7public class MainConfig &#123;89 //注册一个bean,返回Person,bean的id默认读取的方法名1011 @Bean12 public Person person()&#123;13 return new Person(\"iamasd\",20);14 &#125;15&#125; 通过@Configuration和@Bean标签，会将该对象注入到IOC容器中。@Bean中的默认值取该方法名，即person，这相当于&lt;bean id=”person”…&gt;,可以通过@Bean（“xxx”）来自定义beanId值。 以下是测试用例： 1/**2 * @Author: iamasd3 * @Description:4 * @Date: Created in 18:512019/12/65 */67public class TestDemo1 &#123;8910 @Test11 public void run1()&#123;12 AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig.class);13 //ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:application.xml\");14 Person person = (Person)context.getBean(\"person1\");15 System.out.println(person);16 &#125;17&#125;1819结果为：Person&#123;name='iamasd', age=20&#125; 2.总结 通过对以上两种注册Bean的方式做了一个简单的描述，通过@Configuration + @Bean的方式更加简便。","categories":[{"name":"spring","slug":"spring","permalink":"http://www.iamasd.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://www.iamasd.cn/tags/spring/"}]},{"title":"深入理解JVM-----(一)","slug":"jvm1","date":"2019-12-06T14:05:15.000Z","updated":"2019-12-06T15:29:20.434Z","comments":true,"path":"2019/12/06/jvm1/","link":"","permalink":"http://www.iamasd.cn/2019/12/06/jvm1/","excerpt":"","text":"深入理解JVM之运行内存模型1.Jvm运行时数据区 线程共享数据区：方法区 堆 线程隔离数据区：Java虚拟机栈 本地方法栈 程序计数器 程序计数器 程序计数器是一块较小的内存空间，看作当前线程所执行的字节码的行号指示器 字节码治时期工作时事通过改变计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程回复等基础功能都需要依赖这个计数器来完成 内存区域中唯一一个没有规定OutOfMemoryError情况的区域 为什么使用：为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。 Java虚拟机栈作用于方法执行的一块区域 1/**2 * @Author: iamasd3 * @Description:4 * @Date: Created in 22:392019/12/65 */6public class Test &#123;78 public static void a()&#123;9 System.out.println(\"进入a\");10 &#125;1112 public static void b()&#123;13 a();14 System.out.println(\"进入b\");15 &#125;16 public static void main(String[] args) &#123;17 b();18 System.out.println(\"进入main\");19 &#125;20&#125; 打印结果 1进入a2进入b3进入main45Process finished with exit code 0 每个方法的执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成的过程，就对应这一个栈帧再虚拟机栈中入栈到出栈的过程。 局部变量表存放已知以及对象的引用和可知的基本数据类型 由于是递归栈操作，会导致栈溢出操作，抛出StackOverflowError 本地方法栈 作用域本地方法执行的一块java内存区域 与Java虚拟机栈相同的操作 Hotshot将Java虚拟机栈和本地方法栈合二为一 Java堆 是Java内存区域中一块用来存放对象实例的区域 Java堆是java虚拟机所管理内存中最大的一块，同时也是被所有线程共享的一块区域 GC堆 方法区 是各个线程共享的区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据 类信息：类版本号，方法，接口 Hotspot使用永久代来实现方法区JRockit，IBM J9vm java堆一样管理这部分内存 方法区会抛出OutofMemoryError，当他无法满足内存分配 运行时常量池 方法区的一部分，用于存放编译器产生各种字面量和符号引用 方法区会抛出OutofMemoryError，受到方法区内存的限制","categories":[{"name":"jvm","slug":"jvm","permalink":"http://www.iamasd.cn/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://www.iamasd.cn/tags/jvm/"}]}]}