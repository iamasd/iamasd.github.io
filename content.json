{"meta":{"title":"iamasd","subtitle":"Exploration never stops","description":"Exploration never stops","author":"iamasd","url":"http://www.iamasd.cn","root":"/"},"pages":[{"title":"","date":"2019-12-06T03:14:33.246Z","updated":"2019-12-06T03:14:33.240Z","comments":false,"path":"categories/index.html","permalink":"http://www.iamasd.cn/categories/index.html","excerpt":"","text":""},{"title":"友情鏈接","date":"2018-06-07T14:17:49.000Z","updated":"2019-12-06T05:16:00.958Z","comments":true,"path":"link/index.html","permalink":"http://www.iamasd.cn/link/index.html","excerpt":"","text":""},{"title":"分類","date":"2018-01-04T16:00:00.000Z","updated":"2019-12-06T05:14:23.297Z","comments":true,"path":"tags/index.html","permalink":"http://www.iamasd.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"深入理解JVM-----(三)","slug":"jvm3","date":"2019-12-15T11:05:15.000Z","updated":"2019-12-16T15:52:04.386Z","comments":true,"path":"2019/12/15/jvm3/","link":"","permalink":"http://www.iamasd.cn/2019/12/15/jvm3/","excerpt":"","text":"深入理解JVM之GC算法1.对象存活的判断1.1 GC垃圾回收是什么？ 为什么要进行垃圾回收 Java语言中一个最显著的特点就是引入了垃圾回机制，使c++中关于内存的诸多问题迎刃而解。由于存在了垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”，垃圾回收可以有效的防止内存泄漏，有效的使用空闲的内存 怎么判断对象是否该被GC 引用计数法 可达性分析 1.2 对象存活算法引用计数法 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值加1；当引用失效的时候，计数器减1；任何时刻计数器为0的对象就是不可能在被使用的。 优缺点 引用计数器收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利 无法检测出循环引用 1 package cn.sq.test;2 /**3 * @Author: iamasd4 * @Description:5 * @Date: Created in 18:412019/12/76 */7 public class Test1 &#123;8 9 public Object instance = null;10 11 private static final int _1MB = 1024 * 1024;12 /**13 * 增加内存，易于观察内存变化14 */15 16 private byte[] bigSize = new byte[2 * _1MB];171819​ 20 public static void main(String[] args) &#123;21 22 Test1 a = new Test1();23 Test1 b = new Test1();24 25 a.instance = b;26 b.instance = a;27 28 System.gc();29 &#125;30 &#125;313233​ 34 结果：35 [GC (System.gc()) [PSYoungGen: 9339K-&gt;4856K(76288K)] 9339K-&gt;4864K(251392K), 0.0021818 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 36 [Full GC (System.gc()) [PSYoungGen: 4856K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;4765K(175104K)] 4864K-&gt;4765K(251392K), [Metaspace: 3468K-&gt;3468K(1056768K)], 0.0045306 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 37 Heap38 PSYoungGen total 76288K, used 655K [0x000000076b500000, 0x0000000770a00000, 0x00000007c0000000)39 eden space 65536K, 1% used [0x000000076b500000,0x000000076b5a3ee8,0x000000076f500000)40 from space 10752K, 0% used [0x000000076f500000,0x000000076f500000,0x000000076ff80000)41 to space 10752K, 0% used [0x000000076ff80000,0x000000076ff80000,0x0000000770a00000)42 ParOldGen total 175104K, used 4765K [0x00000006c1e00000, 0x00000006cc900000, 0x000000076b500000)43 object space 175104K, 2% used [0x00000006c1e00000,0x00000006c22a7578,0x00000006cc900000)44 Metaspace used 3474K, capacity 4496K, committed 4864K, reserved 1056768K45 class space used 381K, capacity 388K, committed 512K, reserved 1048576K46 47 PSYoungGen表示使用parallel Scavenge收集器，9339KGC之前的内存使用容量 4856KGC之后内存使用的容量 1.3 对象存货算法可达性分析 可达性分析算法的概念（搜索法） 根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作是一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点之后，继续寻找这个节点的引用节点。当所有的引用节点寻找完毕后，剩余的节点则是被认为是没有被引用的节点，即无用的节点 Java中可作为GC ROOT的对象有 虚拟机中引用的对象（本地变量表） 本地方法中的引用的对象 方法区中静态属性引用的对象 方法区中常量引用的对象 2.GC算法2.1 标记清除算法 分为标记和清除两个阶段 首先会标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 不足之处有两点 效率问题，两个阶段的效率都不高 空间问题，在标记清除之后，内存会产生大量不连续的碎片，空间碎片过多可能会导致以后再程序运行过程中需要分配大对象的时候，因为无法分配足够的的连续内存，而又不得不提前出发另一次垃圾收集动作 2.2 复制算法 复制 为了解决效率问题，标记复制算法将可用内存按量划分为大小相等的两块，每次只使用其中的一块 当这一块内存使用完之后，就将还存活着的对象复制到另一块上面，然后把已使用过得内存空间清理掉，这样使得每次都是对整个半区进行内存回收，内存分配时也就不考虑内存碎片等复杂情况，只要移动堆顶的指针，按照顺序分配内存即可。 将内存空间划分为一块较大的Eden空间和两个较小的Survivor空间，每次使用Eden和其中一块Survivor。Survivor from 和Survivor to，内存比例为8：1：1 当内存进行回收的时候，将Eden和Survivor中还存活的对象和一次性的复制到另一块Survivor的空间上，最后清理掉Eden和刚才使用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8：1，也就是每次新生代可用的内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被浪费掉。当Survivor内存空间不够的 时候，就需要依赖其他的内存进行分配担保。 2.3 标记整理算法 复制算法在对象存活率较高时的时候就要进行较多的复制操作，效率会变得很低。更关键的是，如果不想浪费50%的空间，就需要额外的空间进行分配担保，以应用被使用的内存中所有对象都100%存活的极端情况，所以老年代一般不直接选用复制算法 标记整理算法，让所有存活的对象向一端移动，让后直接处理掉端边界以外的内存。 2.4 分代收集算法 新生代使用复制算法 老年代 标记-清除算法 标记-整理算法","categories":[{"name":"jvm","slug":"jvm","permalink":"http://www.iamasd.cn/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://www.iamasd.cn/tags/jvm/"}]},{"title":"Spring基础组件-----@ComponentScan","slug":"ComponentScan","date":"2019-12-11T14:05:15.000Z","updated":"2019-12-11T15:52:54.000Z","comments":true,"path":"2019/12/11/ComponentScan/","link":"","permalink":"http://www.iamasd.cn/2019/12/11/ComponentScan/","excerpt":"","text":"Spring基础组件—–@ComponentScan引言 本篇博文，本着以理解并使用Spring的@ComponentScan扫描类来向IOC容器注入Bean的目的，如果有不正确的地方，还麻烦各位多多指正以下。 1.@ComponentScan1.1 @ComponentScan @ComponentScan主要就是定义扫描的路径从中找出标识了需要装配的类自动装配到spring的bean容器中 1.2 @ComponentScan @ComponentScan注解默认会装配标识了@Controller，@Service，@Repository，@Component注解的类到spring的IOC容器中 首先在package cn.sq.demo2中新建controller和service包 在controller和service包中分别新建一个OrderController类和OrderService类，同时将其各类上注明上相应的@Controller和@Service注解 ​ 1package cn.sq.demo2.controller;23import org.springframework.stereotype.Controller;45/**6 * @Author: iamasd7 * @Description:8 * @Date: Created in 18:452019/12/69 */10@Controller11public class OrderController &#123;12&#125; 1package cn.sq.demo2.service;23import org.springframework.stereotype.Service;45/**6 * @Author: iamasd7 * @Description:8 * @Date: Created in 18:452019/12/69 */10@Service11public class OrderService &#123;12&#125; 在config包下面新建一个MainConfig类，并在其类上使用注解@Configuration声明该类为注解类，同时新增注解@ComponentScan(value = “cn.sq.demo2”)，其中的value的值是要表示，你要扫描的包。 1@Configuration2@ComponentScan(value = \"cn.sq.demo2\")3public class MainConfig &#123;45&#125; 新建测试类 1/**2 * @Author: iamasd3 * @Description:4 * @Date: Created in 19:402019/12/65 */6public class TestDemo2 &#123;78 @Test9 public void run1()&#123;10 AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig.class);1112 String[] names = context.getBeanDefinitionNames();1314 for (String name : names) &#123;15 System.out.println(name);16 &#125;171819 &#125;20&#125;2122结果如下：23mainConfig24orderController25orderDao 该bean是我在OrderDao类上添加了@Repository26orderService ​ 2.@ComponentScan详细配置2.1 @ComponentScan 首先，我们看一下ComponentScan的源代码： 1@Retention(RetentionPolicy.RUNTIME)2@Target(&#123;ElementType.TYPE&#125;)3@Documented4@Repeatable(ComponentScans.class)5public @interface ComponentScan &#123;6 /**7 * 对应的包扫描路径 可以是单个路径，也可以是扫描的路径数组8 * @return9 */10 @AliasFor(\"basePackages\")11 String[] value() default &#123;&#125;;1213 /**14 * 和value一样是对应的包扫描路径 可以是单个路径，也可以是扫描的路径数组15 * @return16 */17 @AliasFor(\"value\")18 String[] basePackages() default &#123;&#125;;1920 /**21 * 指定具体的扫描的类22 * @return23 */24 Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;;2526 /**27 * 对应的bean名称的生成器 默认的是BeanNameGenerator28 * @return29 */30 Class&lt;? extends BeanNameGenerator&gt; nameGenerator() default BeanNameGenerator.class;3132 /**33 * 处理检测到的bean的scope范围34 */35 Class&lt;? extends ScopeMetadataResolver&gt; scopeResolver() default AnnotationScopeMetadataResolver.class;3637 /**38 * 是否为检测到的组件生成代理39 */40 ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT;4142 /**43 * 控制符合组件检测条件的类文件 默认是包扫描下的 **/*.class44 * @return45 */46 String resourcePattern() default \"**/*.class\";4748 /**49 * 是否对带有@Component @Repository @Service @Controller注解的类开启检测,默认是开启的50 * @return51 */52 boolean useDefaultFilters() default true;5354 /**55 * 指定某些定义Filter满足条件的组件 FilterType有5种类型如：56 * ANNOTATION, 注解类型 默认57 ASSIGNABLE_TYPE,指定固定类58 ASPECTJ， ASPECTJ类型59 REGEX,正则表达式60 CUSTOM,自定义类型61 * @return62 */63 ComponentScan.Filter[] includeFilters() default &#123;&#125;;6465 /**66 * 排除某些过来器扫描到的类67 * @return68 */69 ComponentScan.Filter[] excludeFilters() default &#123;&#125;;7071 /**72 * 扫描到的类是都开启懒加载 ，默认是不开启的73 * @return74 */75 boolean lazyInit() default false;7677 @Retention(RetentionPolicy.RUNTIME)78 @Target(&#123;&#125;)79 public @interface Filter &#123;80 FilterType type() default FilterType.ANNOTATION;8182 @AliasFor(\"classes\")83 Class&lt;?&gt;[] value() default &#123;&#125;;8485 @AliasFor(\"value\")86 Class&lt;?&gt;[] classes() default &#123;&#125;;8788 String[] pattern() default &#123;&#125;;89 &#125;90&#125; 2.2 @ComponentScan深入分析1.basePackageClasses 基于在1节中的代码，我们在MainConfig类中的@ComponentScan注解中加入basePackage Classes ，该值会使得@ComponentScan只去扫描其值对应的类。将其注入到Spring容器中 1@Configuration2@ComponentScan(basePackageClasses = OrderService.class)3public class MainConfig &#123;45&#125;67结果：8mainConfig9orderService10同样，basePackageClasses也支持传入多个类11@Configuration12@ComponentScan(basePackageClasses = &#123;OrderService.class, OrderController.class&#125;)13public class MainConfig &#123;1415&#125;16结果：17mainConfig18orderService19orderController 2.includeFilters includeFilters具有过滤功能，是具有包含的关系。所以在使用的时候，需要将useDefaultFilters设置false，不然就会导致过滤效果没有体现出来。 11.根据注解的类型来过滤，例如只允许带有@Controller注解类的类注册2@Configuration3@ComponentScan(value = \"cn.sq.demo2\",includeFilters = &#123;4 @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;5 )&#125;,useDefaultFilters = false)6public class MainConfig &#123;7&#125;89结果：10mainConfig11orderController12132.只允许固定类注册14@Configuration15@ComponentScan(value = \"cn.sq.demo2\",includeFilters = &#123;16 @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = &#123;OrderService.class&#125;17 )&#125;,useDefaultFilters = false)18public class MainConfig &#123;19&#125;20结果：21mainConfig22orderService23243.自定义注册25新建立一个MyTypeFilter并实现TypeFilter，此时MyTypeFilter就可以写条件判断，return trun即为执行匹配。26package cn.sq.demo2.config;2728import org.springframework.beans.factory.annotation.Autowired;29import org.springframework.core.io.Resource;30import org.springframework.core.type.AnnotationMetadata;31import org.springframework.core.type.ClassMetadata;32import org.springframework.core.type.classreading.MetadataReader;33import org.springframework.core.type.classreading.MetadataReaderFactory;34import org.springframework.core.type.filter.TypeFilter;3536import java.io.IOException;3738/**39 * @Author: iamasd40 * @Description:41 * @Date: Created in 19:222019/12/642 */43public class MyTypeFilter implements TypeFilter &#123;4445 @Autowired46 /**47 *48 * @param metadataReader 元数据 读取到当前正在扫描类的信息49 * @param metadataReaderFactory 可以获取到其他任何类的信息50 * @return51 * @throws IOException52 */53 @Override54 public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123;5556 //获取当前类注解的信息57 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();58 //获取当前正在扫秒类的信息59 ClassMetadata classMetadata = metadataReader.getClassMetadata();60 //获取当前类的资源61 Resource resource = metadataReader.getResource();6263 String className = classMetadata.getClassName();6465 System.out.println(\"-========--正在扫描\"+className);6667 //包含er字符匹配成功68 if (className.contains(\"er\"))&#123;69 return true;70 &#125;71 return false;72 &#125;73&#125;74结果：75mainConfig76myTypeFilter77orderController78orderDao79orderService80其只扫描到bean中有er的 excludeFilters excludeFilters具有过滤功能，是具有排除的关系。所以在使用的时候，需要将useDefaultFilters设置true，不然就会导致过滤效果没有体现出来。 excludeFilters的操作与includeFilters都相同，此处便不再多啰嗦说明了。 3.总结 自定扫描路径下边带有@Controller，@Service，@Repository，@Component注解加入spring容器 通过includeFilters加入扫描路径下没有以上注解的类加入spring容器 通过excludeFilters过滤出不用加入spring容器的类 自定义增加了@Component注解的注解方式 话外直言，本篇博文在过滤类型中，没有说明ASPECTJ， ASPECTJ类型与 REGEX,正则表达式的过滤条件，由于本人未曾使用到过，所以未曾研究下，之后如果遇到便会更新博文，有不足之处，还望海涵。 推荐一个个人Spring组件精简的博客： https://yq.aliyun.com/articles/29137 https://yq.aliyun.com/users/226fvk6vfzlti?spm=a2c4e.11153940.0.0.122f5995WV9FGD 千里之行始于足下","categories":[{"name":"spring","slug":"spring","permalink":"http://www.iamasd.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://www.iamasd.cn/tags/spring/"}]},{"title":"深入理解JVM-----(二)","slug":"jvm2","date":"2019-12-10T11:05:15.000Z","updated":"2019-12-10T13:33:41.270Z","comments":true,"path":"2019/12/10/jvm2/","link":"","permalink":"http://www.iamasd.cn/2019/12/10/jvm2/","excerpt":"","text":"深入理解JVM之对象1.对象是怎么来的？1.1 对象的创建 对象创建的流程 虚拟机遇到一条new指令是，首先会检查这个对应的类能否在常量池中定义到一个类的符号引用 判断这个类是否已被加载，解析以及初始化 问这个新对象在Java队中分配内存空间——2种方法 指针碰撞 空闲列表 将分配的内存空间初始化为零值 设置对象头数据 GC分代年龄 对象的哈希码hashCode 元数据信息 执行对象方法 1.2 对象结构 对象头用于存储对象的元数据信息： Mark Word 部分数据的长度为32bit或64bit，存储对象自身运行时的数据—哈希值等。Mark Word一般被设计为非固定的数据结构，以便于存储更多的数据信息和复用自己的存储空间 类型指针：指向它的类元数据的指针，用于判断对象属于那个类的实例。 示例数据存储的时真正有效的数据。 对其填充部分只起到占位符的作用。 2.如何访问对象？2.1 对象的访问 在堆上创建一个对象实例之后，就要通过虚拟机栈中的reference类型数据来操作堆上的对象。 使用句柄访问 直接指针访问（HotSpot虚拟机） 2.2 对比 垃圾回收对比：1中，当垃圾回收移动对象时，reference中存储的地址时稳定的地址，不需要修改，仅需要修改对象句柄的地址；2中，垃圾回收的时候只需要修改reference中存储的地址。 访问效率分析，2&gt;1,因为2只进行了一次指针定位，节省了时间的开销 3.注解 指针碰撞 分配内存空间包括开辟一块内存和移动指针两个步骤 通俗来讲，在一块内存区域中，存在一个指针，当一个对象创建需要内存空间的时候，指针就向未使用的内存移动相应要创建内存大小的位置。它就像一块围墙，将使用与未使用的内存空间隔离。 非原子步骤可能会出项并发问题，Java虚拟机采用CAS(乐观锁)配上失败重试的方式来保证更新的操作原子性 空闲列表 分配内存空间包括开辟一块内存，和修改空闲列表两个步骤。 分配表相当于一个宿管阿姨的登记表，你要住宿，那就给你登记，分配住房。 非原子步骤可能会出项并发问题，Java虚拟机采用CAS(乐观锁)配上失败重试的方式来保证更新的操作原子性","categories":[{"name":"jvm","slug":"jvm","permalink":"http://www.iamasd.cn/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://www.iamasd.cn/tags/jvm/"}]},{"title":"Spring基础组件-----@Configuration","slug":"Configuration","date":"2019-12-09T01:05:15.000Z","updated":"2019-12-09T02:49:52.000Z","comments":true,"path":"2019/12/09/Configuration/","link":"","permalink":"http://www.iamasd.cn/2019/12/09/Configuration/","excerpt":"","text":"Spring基础组件—-@Configuration引言 本篇博文，本着简易使用以及简易理解的目的，不针对源码进行分析。如果有不正确的地方，还麻烦各位多多指正以下。Bean的注册有6种方式，本文只讨论2种 1.Bean1.1 Spring XML 创建Bean 在原始的操作中，我们会使用Spring XML的方式来配置。这样的使用，会使得在之后注册大量的bean，导致XML配置文件膨胀，不利于对象的操作。 这里先创建一个Person类： 1/**2 * @Author: iamasd3 * @Description:4 * @Date: Created in 18:112019/12/65 */6public class Person &#123;78 private String name;910 private Integer age;1112 public Person(String name, Integer age) &#123;13 this.name = name;14 this.age = age;15 &#125;1617 public String getName() &#123;18 return name;19 &#125;2021 public void setName(String name) &#123;22 this.name = name;23 &#125;2425 public Integer getAge() &#123;26 return age;27 &#125;2829 public void setAge(Integer age) &#123;30 this.age = age;31 &#125;3233 @Override34 public String toString() &#123;35 return \"Person&#123;\" +36 \"name='\" + name + '\\'' +37 \", age=\" + age +38 '&#125;';39 &#125;40&#125; 接下来是XML文件的配置： 1&lt;bean id=\"person\" class=\"cn.sq.demo1.Person\"&gt;2 &lt;constructor-arg index=\"0\" value=\"iamasd\"/&gt;3 &lt;constructor-arg index=\"1\" value=\"18\"/&gt;4&lt;/bean&gt; 这样的是通过有参构造器，在向IOC容器注册Bean的时候，通过构造器对其属性值进行赋值操作。或者我们可以不通过对象的构造器，将Person中的构造器注释，直接在XML的文件中通过Bean标签中的property标签，对对象内的属性赋值。 1&lt;bean id=\"person\" class=\"cn.sq.demo1.Person\"&gt;2 &lt;property name=\"name\" value=\"iamasd\"/&gt;3 &lt;property name=\"age\" value=\"18\"/&gt;4&lt;/bean&gt; 写一个测试用例 1/**2 * @Author: iamasd3 * @Description:4 * @Date: Created in 18:512019/12/65 */67public class TestDemo1 &#123;8910 @Test11 public void run1()&#123;12 //AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig.class);13 ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:application.xml\");14 Person person = (Person)context.getBean(\"person\");15 System.out.println(person);16 &#125;17&#125;1819结果：Person&#123;name='iamasd', age=18&#125;202122以上便是最基础的XML配置，使对象注入到IOC容器中。但是，随着要注册的对象增多，会导致XML文件的臃肿，不推荐使用。 1.2 @Configuration+@Bean 除了第一个方法，我们还可以通过@Configuration这个注解，来表明这是一个配置类， 这个类可以使用Spring IoC容器作为bean定义的来源。 @Bean 注解在该类的方法上，AnnotationConfigApplicationContext将配置类中标注了 @Bean的方法的返回值识别为Spring Bean，并注册到容器中，归入IoC容器管理。其定义意义上上等同于Spring XML文件中的标签。 以下是一个简单的实例： 1/**2 * @Author: iamasd3 * @Description:4 * @Date: Created in 18:222019/12/65 */6@Configuration7public class MainConfig &#123;89 //注册一个bean,返回Person,bean的id默认读取的方法名1011 @Bean12 public Person person()&#123;13 return new Person(\"iamasd\",20);14 &#125;15&#125; 通过@Configuration和@Bean标签，会将该对象注入到IOC容器中。@Bean中的默认值取该方法名，即person，这相当于&lt;bean id=”person”…&gt;,可以通过@Bean（“xxx”）来自定义beanId值。 以下是测试用例： 1/**2 * @Author: iamasd3 * @Description:4 * @Date: Created in 18:512019/12/65 */67public class TestDemo1 &#123;8910 @Test11 public void run1()&#123;12 AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig.class);13 //ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:application.xml\");14 Person person = (Person)context.getBean(\"person1\");15 System.out.println(person);16 &#125;17&#125;1819结果为：Person&#123;name='iamasd', age=20&#125; 2.总结 通过对以上两种注册Bean的方式做了一个简单的描述，通过@Configuration + @Bean的方式更加简便。","categories":[{"name":"spring","slug":"spring","permalink":"http://www.iamasd.cn/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://www.iamasd.cn/tags/spring/"}]},{"title":"深入理解JVM-----(一)","slug":"jvm1","date":"2019-12-06T14:05:15.000Z","updated":"2019-12-06T15:29:20.434Z","comments":true,"path":"2019/12/06/jvm1/","link":"","permalink":"http://www.iamasd.cn/2019/12/06/jvm1/","excerpt":"","text":"深入理解JVM之运行内存模型1.Jvm运行时数据区 线程共享数据区：方法区 堆 线程隔离数据区：Java虚拟机栈 本地方法栈 程序计数器 程序计数器 程序计数器是一块较小的内存空间，看作当前线程所执行的字节码的行号指示器 字节码治时期工作时事通过改变计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程回复等基础功能都需要依赖这个计数器来完成 内存区域中唯一一个没有规定OutOfMemoryError情况的区域 为什么使用：为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。 Java虚拟机栈作用于方法执行的一块区域 1/**2 * @Author: iamasd3 * @Description:4 * @Date: Created in 22:392019/12/65 */6public class Test &#123;78 public static void a()&#123;9 System.out.println(\"进入a\");10 &#125;1112 public static void b()&#123;13 a();14 System.out.println(\"进入b\");15 &#125;16 public static void main(String[] args) &#123;17 b();18 System.out.println(\"进入main\");19 &#125;20&#125; 打印结果 1进入a2进入b3进入main45Process finished with exit code 0 每个方法的执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成的过程，就对应这一个栈帧再虚拟机栈中入栈到出栈的过程。 局部变量表存放已知以及对象的引用和可知的基本数据类型 由于是递归栈操作，会导致栈溢出操作，抛出StackOverflowError 本地方法栈 作用域本地方法执行的一块java内存区域 与Java虚拟机栈相同的操作 Hotshot将Java虚拟机栈和本地方法栈合二为一 Java堆 是Java内存区域中一块用来存放对象实例的区域 Java堆是java虚拟机所管理内存中最大的一块，同时也是被所有线程共享的一块区域 GC堆 方法区 是各个线程共享的区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据 类信息：类版本号，方法，接口 Hotspot使用永久代来实现方法区JRockit，IBM J9vm java堆一样管理这部分内存 方法区会抛出OutofMemoryError，当他无法满足内存分配 运行时常量池 方法区的一部分，用于存放编译器产生各种字面量和符号引用 方法区会抛出OutofMemoryError，受到方法区内存的限制","categories":[{"name":"jvm","slug":"jvm","permalink":"http://www.iamasd.cn/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://www.iamasd.cn/tags/jvm/"}]}]}